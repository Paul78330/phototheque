# Utilise l'image Docker 'docker/compose:latest' pour exécuter les jobs de ce pipeline
image: docker/compose:latest

# Utilise le service 'docker:dind' (Docker in Docker) pour permettre l'exécution de Docker à l'intérieur des jobs
services:
  - docker:dind

# Définit les étapes du pipeline
stages:
  - build
  - test
  - debug

# Définit des variables d'environnement pour Docker
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

# Exécute 'docker info' avant chaque job pour afficher des informations sur l'environnement Docker
before_script:
  - docker info

# Job 'build' pour construire les images Docker de l'application
build:
  stage: build
  script:
    - docker-compose build
  # Conserve l'ensemble du répertoire de travail comme artefact pour les jobs suivants
  artifacts:
    paths:
      - ./

# Job 'tests_unitaires' pour exécuter les tests unitaires de l'application
tests_unitaires:
  stage: test
  script:
    - docker-compose up --build --exit-code-from test
  artifacts:
    reports:
      junit: test-results/resultat_tests.xml
    paths:
      - test-results/resultat_tests.xml
    when: always

# Job 'tests_integration' pour exécuter les tests d'intégration de l'application
tests_integration:
  stage: test
  script:
    - docker-compose up -d app
    - docker-compose run -T app npm run test:integration
    - docker-compose down
  artifacts:
    reports:
      junit: integration-test-results/resultat_tests_integration.xml
    paths:
      - integration-test-results/resultat_tests_integration.xml
    when: always

# Job 'tests_e2e' pour exécuter les tests end-to-end (e2e) avec Cypress
tests_e2e:
  stage: test
  # Les commandes à exécuter pour ce job
  script:
    - docker-compose up -d app
    - dockerize -wait tcp://app:3000 -timeout 1m
    - docker-compose up cypress
    - docker-compose down
  artifacts:
    # Les chemins des artefacts à sauvegarder
    # Ici, ce sont les vidéos et les captures d'écran générées par Cypress
    paths:
      - cypress/videos/*
      - cypress/screenshots/*
      - download/*
    # Les artefacts sont toujours sauvegardés, même si le job échoue
    when: always

# Job 'debug_job' pour afficher des informations de débogage
debug_job:
  image: cypress/included:13.6.4
  stage: debug
  script:
    - echo "Debug information:"
    - docker-compose config
    - docker-compose ps
    - docker-compose logs
  # Exécute ce job uniquement sur les branches autres que 'master'
  only:
    - branches
  except:
    - master

# docker-compose down: Cette commande arrête et supprime les conteneurs, réseaux et volumes définis dans votre fichier docker-compose.yml.
# artifacts: Ce sont les fichiers qui sont conservés après l'exécution de ce job.
# paths: C'est la liste des chemins des fichiers à conserver. Ici, nous conservons les vidéos et les captures d'écran générées par Cypress lors de l'exécution des tests.
# when: always: Cela signifie que les artefacts sont toujours conservés, même si le job échoue.
# debug_job: C'est le nom du job dans votre pipeline GitLab CI/CD.
# stage: debug: Cela signifie que ce job est exécuté pendant l'étape debug de votre pipeline.
# script: Ce sont les commandes qui sont exécutées pour ce job.
# echo "Debug information:": Cette commande affiche le texte "Debug information:" dans la sortie du job.
# docker-compose config: Cette commande affiche votre configuration Docker Compose.
# docker-compose ps: Cette commande affiche l'état des services définis dans votre fichier docker-compose.yml.
# docker-compose logs: Cette commande affiche les logs des services définis dans votre fichier docker-compose.yml.
# only et except: Ces deux clés définissent les règles pour déterminer quand ce job doit être exécuté. Ici, le job debug_job est exécuté uniquement sur les branches autres que master.
